From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/en_sysfs.c

---
 .../ethernet/mellanox/mlx5/core/en_sysfs.c    | 131 +++++++++++++++++-
 1 file changed, 124 insertions(+), 7 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en_sysfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_sysfs.c
@@ -32,6 +32,9 @@
 
 #include <linux/device.h>
 #include <linux/netdevice.h>
+#ifdef HAVE_BASECODE_EXTRAS
+#include <linux/dcbnl.h>
+#endif
 #include "en.h"
 #include "en_tc.h"
 #include "eswitch.h"
@@ -64,7 +67,7 @@ static ssize_t mlx5e_store_tc_num(struct
 {
 	struct mlx5e_priv *priv = netdev_priv(to_net_dev(device));
 	struct net_device *netdev = priv->netdev;
-	struct tc_mqprio_qopt_offload mqprio = { 0 };
+	struct tc_mqprio_qopt_offload mqprio = {{ 0 }};
 	int tc_num;
 	int err = 0;
 
@@ -285,11 +288,21 @@ static ssize_t mlx5e_show_hfunc(struct d
 {
 	struct mlx5e_priv *priv = netdev_priv(to_net_dev(device));
 	u8 hfunc;
+#ifndef HAVE_CORE_TRACKS_CUSTOM_RSS_CONTEXTS
+	int err;
+#endif
 	int len = 0;
 
 	rtnl_lock();
 	mutex_lock(&priv->state_lock);
-	mlx5e_rx_res_rss_get_rxfh(priv->rx_res, 0, NULL, NULL, &hfunc, NULL);
+#ifndef HAVE_CORE_TRACKS_CUSTOM_RSS_CONTEXTS
+	err =
+#endif
+		mlx5e_rx_res_rss_get_rxfh(priv->rx_res, 0, NULL, NULL, &hfunc
+#ifdef HAVE_RXH_XFRM_SYM_OR_XOR
+				  , NULL
+#endif
+				  );
 	mutex_unlock(&priv->state_lock);
 
 	len += sprintf(buf + len, "Operational hfunc: %s\n",
@@ -299,7 +312,11 @@ static ssize_t mlx5e_show_hfunc(struct d
 
 	rtnl_unlock();
 
+#ifndef HAVE_CORE_TRACKS_CUSTOM_RSS_CONTEXTS
+	return err ? err : len;
+#else
 	return len;
+#endif
 }
 
 static ssize_t mlx5e_store_hfunc(struct device *device,
@@ -333,7 +350,11 @@ static ssize_t mlx5e_store_hfunc(struct
 			goto unlock;
 	}
 	err = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, 0, NULL, NULL,
-					&ethtool_hfunc, NULL);
+					&ethtool_hfunc
+#ifdef HAVE_RXH_XFRM_SYM_OR_XOR
+					, NULL
+#endif
+					);
 	mutex_unlock(&priv->state_lock);
 	rtnl_unlock();
 
@@ -359,11 +380,21 @@ static ssize_t mlx5e_show_xfrm(struct de
 {
 	struct mlx5e_priv *priv = netdev_priv(to_net_dev(device));
 	bool symmetric = false;
+#ifndef HAVE_CORE_TRACKS_CUSTOM_RSS_CONTEXTS
+	int err;
+#endif
 	int len = 0;
 
 	rtnl_lock();
 	mutex_lock(&priv->state_lock);
-	mlx5e_rx_res_rss_get_rxfh(priv->rx_res, 0, NULL, NULL, NULL, &symmetric);
+#ifndef HAVE_CORE_TRACKS_CUSTOM_RSS_CONTEXTS
+	err =
+#endif
+	mlx5e_rx_res_rss_get_rxfh(priv->rx_res, 0, NULL, NULL, NULL
+#ifdef HAVE_RXH_XFRM_SYM_OR_XOR
+				  , &symmetric
+#endif
+				  );
 	mutex_unlock(&priv->state_lock);
 	rtnl_unlock();
 
@@ -371,7 +402,11 @@ static ssize_t mlx5e_show_xfrm(struct de
 		       symmetric == true ?  "symmetric-or-xor" : "none");
 	len += sprintf(buf + len, "Supported xfrm: symmetric-or-xor none\n");
 
+#ifndef HAVE_CORE_TRACKS_CUSTOM_RSS_CONTEXTS
+	return err ? err : len;
+#else
 	return len;
+#endif
 }
 
 static ssize_t mlx5e_store_xfrm(struct device *device,
@@ -398,7 +433,11 @@ static ssize_t mlx5e_store_xfrm(struct d
 
 	rtnl_lock();
 	mutex_lock(&priv->state_lock);
-	err = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, 0, NULL, NULL, NULL, &symmetric);
+	err = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, 0, NULL, NULL, NULL
+#ifdef HAVE_RXH_XFRM_SYM_OR_XOR
+					, &symmetric
+#endif
+					);
 	mutex_unlock(&priv->state_lock);
 	rtnl_unlock();
 	return err ? err : count;
@@ -1001,11 +1040,9 @@ static ssize_t mlx5e_store_force_local_l
 	struct mlx5_core_dev *mdev = priv->mdev;
 	bool disable;
 	int err;
-
 	err = kstrtobool(buf, &disable);
 	if (err)
 		return -EINVAL;
-
 	if (mdev->local_lb.user_force_disable != disable) {
 		mdev->local_lb.user_force_disable = disable;
 		mlx5_nic_vport_update_local_lb(mdev,
@@ -1019,6 +1056,64 @@ static DEVICE_ATTR(force_local_lb_disabl
 		   mlx5e_show_force_local_lb,
 		   mlx5e_store_force_local_lb);
 
+#if !defined(HAVE_PAGE_POOL_DEFRAG_PAGE) && !defined(HAVE_PAGE_POOL_PUT_UNREFED_PAGE)
+static ssize_t mlx5e_show_log_rx_page_cache_mult_limit(struct device *device,
+						       struct device_attribute *attr,
+						       char *buf)
+{
+	struct net_device *dev = to_net_dev(device);
+	struct mlx5e_priv *priv = netdev_priv(dev);
+	int len;
+
+	mutex_lock(&priv->state_lock);
+	len = sprintf(buf, "log rx page cache mult limit is %u\n",
+		      priv->channels.params.log_rx_page_cache_mult);
+	mutex_unlock(&priv->state_lock);
+
+	return len;
+}
+
+static ssize_t mlx5e_store_log_rx_page_cache_mult_limit(struct device *device,
+							struct device_attribute *attr,
+							const char *buf,
+							size_t count)
+{
+	struct net_device *dev = to_net_dev(device);
+	struct mlx5e_priv *priv = netdev_priv(dev);
+	int err, udata;
+
+	err = kstrtoint(buf, 0, &udata);
+	if (err)
+		return -EINVAL;
+
+	if (udata > MLX5E_PAGE_CACHE_LOG_MAX_RQ_MULT || udata < 0) {
+		netdev_err(priv->netdev, "log rx page cache mult limit cannot exceed above %d or below 0\n",
+			   MLX5E_PAGE_CACHE_LOG_MAX_RQ_MULT);
+		return -EINVAL;
+	}
+
+	mutex_lock(&priv->state_lock);
+	priv->channels.params.log_rx_page_cache_mult = (u8)udata;
+	mutex_unlock(&priv->state_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(log_mult_limit, S_IRUGO | S_IWUSR,
+		   mlx5e_show_log_rx_page_cache_mult_limit,
+		   mlx5e_store_log_rx_page_cache_mult_limit);
+
+static struct attribute *mlx5e_log_rx_page_cache_attrs[] = {
+	&dev_attr_log_mult_limit.attr,
+	NULL,
+};
+
+static struct attribute_group rx_page_cache_group = {
+	.name = "rx_page_cache",
+	.attrs = mlx5e_log_rx_page_cache_attrs,
+};
+#endif /*HAVE_PAGE_POOL_DEFRAG_PAGE*/
+
 static struct attribute *mlx5e_settings_attrs[] = {
 	&dev_attr_hfunc.attr,
 	&dev_attr_xfrm.attr,
@@ -1234,11 +1329,17 @@ static struct attribute *prio_hp_attrs[]
 	NULL
 };
 
+#ifdef HAVE_KOBJ_TYPE_DEFAULT_GROUPS
 ATTRIBUTE_GROUPS(prio_hp);
+#endif
 
 static struct kobj_type prio_hp_sysfs = {
 	.sysfs_ops     = &prio_hp_ops,
+#ifdef HAVE_KOBJ_TYPE_DEFAULT_GROUPS
 	.default_groups = prio_hp_groups
+#else
+	.default_attrs = prio_hp_attrs
+#endif
 };
 
 int create_prio_hp_sysfs(struct mlx5e_priv *priv, int prio)
@@ -1560,9 +1661,18 @@ int mlx5e_sysfs_create(struct net_device
 	if (err)
 		goto remove_debug_group;
 
+#if !defined(HAVE_PAGE_POOL_DEFRAG_PAGE) && !defined(HAVE_PAGE_POOL_PUT_UNREFED_PAGE)
+	err = sysfs_create_group(&dev->dev.kobj, &rx_page_cache_group);
+	if (err)
+		goto remove_phy_stat_group;
+#endif
 	err = hp_sysfs_init(priv);
 	if (err)
+#if !defined(HAVE_PAGE_POOL_DEFRAG_PAGE) && !defined(HAVE_PAGE_POOL_PUT_UNREFED_PAGE)
+		goto remove_rx_page_cache_group;
+#else
 		goto remove_phy_stat_group;
+#endif
 
 	mlx5_eswitch_compat_sysfs_init(dev);
 
@@ -1580,6 +1690,10 @@ int mlx5e_sysfs_create(struct net_device
 
 	return 0;
 
+#if !defined(HAVE_PAGE_POOL_DEFRAG_PAGE) && !defined(HAVE_PAGE_POOL_PUT_UNREFED_PAGE)
+remove_rx_page_cache_group:
+	sysfs_remove_group(&dev->dev.kobj, &rx_page_cache_group);
+#endif
 remove_phy_stat_group:
 	sysfs_remove_group(&dev->dev.kobj, &phy_stat_group);
 remove_debug_group:
@@ -1607,6 +1721,9 @@ void mlx5e_sysfs_remove(struct net_devic
 	sysfs_remove_group(&dev->dev.kobj, &debug_group);
 	sysfs_remove_group(&dev->dev.kobj, &settings_group);
 	sysfs_remove_group(&dev->dev.kobj, &phy_stat_group);
+#if !defined(HAVE_PAGE_POOL_DEFRAG_PAGE) && !defined(HAVE_PAGE_POOL_PUT_UNREFED_PAGE)
+	sysfs_remove_group(&dev->dev.kobj, &rx_page_cache_group);
+#endif
 	hp_sysfs_cleanup(priv);
 
 	if (mlx5_core_is_vf(priv->mdev))
