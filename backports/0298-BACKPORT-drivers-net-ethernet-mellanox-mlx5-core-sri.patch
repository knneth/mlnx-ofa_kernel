From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/sriov.c

Change-Id: I9494765b71b6c1daa51d6b2701040ede9f2eb4df
---
 .../net/ethernet/mellanox/mlx5/core/sriov.c   | 40 ++++++++++++++++++-
 1 file changed, 39 insertions(+), 1 deletion(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
@@ -73,7 +73,10 @@ static int sriov_restore_guids(struct ml
 static int mlx5_device_enable_sriov(struct mlx5_core_dev *dev, int num_vfs)
 {
 	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
-	int err, vf, num_msix_count;
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
+	int num_msix_count;
+#endif
+	int err, vf;
 	int vport_num;
 
 	err = mlx5_eswitch_enable(dev->priv.eswitch, num_vfs);
@@ -93,7 +96,9 @@ static int mlx5_device_enable_sriov(stru
 		return err;
 	}
 
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 	num_msix_count = mlx5_get_default_msix_vec_count(dev, num_vfs);
+#endif
 	for (vf = 0; vf < num_vfs; vf++) {
 		/* Notify the VF before its enablement to let it set
 		 * some stuff.
@@ -106,6 +111,7 @@ static int mlx5_device_enable_sriov(stru
 			continue;
 		}
 
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 		err = mlx5_set_msix_vec_count(dev, vf + 1, num_msix_count);
 		if (err) {
 			mlx5_core_warn(dev,
@@ -113,6 +119,7 @@ static int mlx5_device_enable_sriov(stru
 				       vf, err);
 			continue;
 		}
+#endif
 
 		sriov->vfs_ctx[vf].enabled = 1;
 		if (MLX5_CAP_GEN(dev, port_type) == MLX5_CAP_PORT_TYPE_IB) {
@@ -192,15 +199,21 @@ mlx5_device_disable_sriov(struct mlx5_co
 static int mlx5_sriov_enable(struct pci_dev *pdev, int num_vfs)
 {
 	struct mlx5_core_dev *dev  = pci_get_drvdata(pdev);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	struct devlink *devlink = priv_to_devlink(dev);
 	struct mlxdevm *mlxdevm = &mlx5_devm_device_get(dev)->device;
+#endif
 	int err;
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_lock(devlink);
 	devm_lock(mlxdevm);
+#endif
 	err = mlx5_device_enable_sriov(dev, num_vfs);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devm_unlock(mlxdevm);
 	devl_unlock(devlink);
+#endif
 	if (err) {
 		mlx5_core_warn(dev, "mlx5_device_enable_sriov failed : %d\n", err);
 		return err;
@@ -209,11 +222,15 @@ static int mlx5_sriov_enable(struct pci_
 	err = pci_enable_sriov(pdev, num_vfs);
 	if (err) {
 		mlx5_core_warn(dev, "pci_enable_sriov failed : %d\n", err);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 		devl_lock(devlink);
 		devm_lock(mlxdevm);
+#endif
 		mlx5_device_disable_sriov(dev, num_vfs, true, true);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 		devm_unlock(mlxdevm);
 		devl_unlock(devlink);
+#endif
 	}
 	return err;
 }
@@ -221,16 +238,22 @@ static int mlx5_sriov_enable(struct pci_
 void mlx5_sriov_disable(struct pci_dev *pdev, bool num_vf_change)
 {
 	struct mlx5_core_dev *dev  = pci_get_drvdata(pdev);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	struct devlink *devlink = priv_to_devlink(dev);
 	struct mlxdevm *mlxdevm = &mlx5_devm_device_get(dev)->device;
+#endif
 	int num_vfs = pci_num_vf(dev->pdev);
 
 	pci_disable_sriov(pdev);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_lock(devlink);
 	devm_lock(mlxdevm);
+#endif
 	mlx5_device_disable_sriov(dev, num_vfs, true, num_vf_change);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devm_unlock(mlxdevm);
 	devl_unlock(devlink);
+#endif
 }
 
 int mlx5_core_sriov_configure(struct pci_dev *pdev, int num_vfs)
@@ -251,6 +274,7 @@ int mlx5_core_sriov_configure(struct pci
 	return err ? err : num_vfs;
 }
 
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 int mlx5_core_sriov_set_msix_vec_count(struct pci_dev *vf, int msix_vec_count)
 {
 	struct pci_dev *pf = pci_physfn(vf);
@@ -268,12 +292,26 @@ int mlx5_core_sriov_set_msix_vec_count(s
 			mlx5_get_default_msix_vec_count(dev, pci_num_vf(pf));
 
 	sriov = &dev->priv.sriov;
+#ifdef HAVE_PCI_IOV_VF_ID
 	id = pci_iov_vf_id(vf);
 	if (id < 0 || !sriov->vfs_ctx[id].enabled)
+#else
+	/* Reversed translation of PCI VF function number to the internal
+	 * function_id, which exists in the name of virtfn symlink. */
+	for (id = 0; id < pci_num_vf(pf); id++) {
+		if (!sriov->vfs_ctx[id].enabled)
+			continue;
+
+		if (vf->devfn == pci_iov_virtfn_devfn(pf, id))
+			break;
+	}
+	if (id == pci_num_vf(pf) || !sriov->vfs_ctx[id].enabled)
+#endif
 		return -EINVAL;
 
 	return mlx5_set_msix_vec_count(dev, id + 1, msix_vec_count);
 }
+#endif
 
 int mlx5_sriov_attach(struct mlx5_core_dev *dev)
 {
