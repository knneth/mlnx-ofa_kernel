From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: net/mlxdevm/netlink.c

Change-Id: I8d05d84be7f2e5e2477878963c032a50d1ab56d8
---
 net/mlxdevm/netlink.c | 129 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 128 insertions(+), 1 deletion(-)

--- a/net/mlxdevm/netlink.c
+++ b/net/mlxdevm/netlink.c
@@ -5,7 +5,9 @@
  */
 #include <net/genetlink.h>
 #include <net/sock.h>
+#ifdef HAVE_DEVL_PORT_REGISTER
 #include <net/devlink.h>
+#endif
 
 #include "devl_internal.h"
 
@@ -18,6 +20,7 @@ static const struct genl_multicast_group
 	[MLXDEVM_MCGRP_CONFIG] = { .name = MLXDEVM_GENL_MCGRP_CONFIG_NAME },
 };
 
+#ifdef HAVE_DEVLINK_NOTIFICATIONS_FILTERING
 struct mlxdevm_nl_sock_priv {
 	struct mlxdevm_obj_desc __rcu *flt;
 	spinlock_t flt_lock; /* Protects flt. */
@@ -38,8 +41,9 @@ static void mlxdevm_nl_sock_priv_destroy
 	flt = rcu_dereference_protected(sk_priv->flt, true);
 	kfree_rcu(flt, rcu);
 }
-#ifdef HAVE_BLOCKED_DEVLINK_CODE
+#endif
 
+#ifdef HAVE_BLOCKED_DEVLINK_CODE
 int devlink_nl_notify_filter_set_doit(struct sk_buff *skb,
 				      struct genl_info *info)
 {
@@ -100,6 +104,7 @@ int devlink_nl_notify_filter_set_doit(st
 }
 #endif
 
+#ifdef HAVE_DEVLINK_NOTIFICATIONS_FILTERING
 static bool mlxdevm_obj_desc_match(const struct mlxdevm_obj_desc *desc,
 				   const struct mlxdevm_obj_desc *flt)
 {
@@ -128,6 +133,7 @@ static bool mlxdevm_obj_desc_match(const
  * Return: valid pointer on success, otherwise negative error value
  * encoded by ERR_PTR(), NULL in case priv does not exist.
  */
+
 static void *mlxdevm__genl_sk_priv_get(struct genl_family *family, struct sock *sk)
 {
 	if (WARN_ON_ONCE(!family->sock_privs))
@@ -152,12 +158,15 @@ int mlxdevm_nl_notify_filter(struct sock
 	rcu_read_unlock();
 	return ret;
 }
+#endif
 
 int mlxdevm_nl_put_nested_handle(struct sk_buff *msg, struct net *net,
 				 struct mlxdevm *mlxdevm, int attrtype)
 {
 	struct nlattr *nested_attr;
+#ifdef HAVE_READ_PNET_RCU
 	struct net *devl_net;
+#endif
 
 	nested_attr = nla_nest_start(msg, attrtype);
 	if (!nested_attr)
@@ -165,16 +174,27 @@ int mlxdevm_nl_put_nested_handle(struct
 	if (mlxdevm_nl_put_handle(msg, mlxdevm))
 		goto nla_put_failure;
 
+#ifdef HAVE_READ_PNET_RCU
 	rcu_read_lock();
 	devl_net = read_pnet_rcu(&mlxdevm->_net);
 	if (!net_eq(net, devl_net)) {
 		int id = peernet2id_alloc(net, devl_net, GFP_ATOMIC);
 
 		rcu_read_unlock();
+#else
+	if (!net_eq(net, read_pnet(&mlxdevm->_net))) {
+#ifdef HAVE_PEERNET2ID_ALLOC_GET_3_PARAMS
+		int id = peernet2id_alloc(net, read_pnet(&mlxdevm->_net),GFP_KERNEL);
+#else
+		int id = peernet2id_alloc(net, read_pnet(&mlxdevm->_net));
+#endif
+#endif
 		if (nla_put_s32(msg, MLXDEVM_ATTR_NETNS_ID, id))
 			return -EMSGSIZE;
+#ifdef HAVE_READ_PNET_RCU
 	} else {
 		rcu_read_unlock();
+#endif
 	}
 
 	nla_nest_end(msg, nested_attr);
@@ -205,7 +225,9 @@ mlxdevm_get_from_attrs_lock(struct net *
 			    bool dev_lock)
 {
 	struct mlxdevm *mlxdevm;
+#ifdef HAVE_DEVL_PORT_REGISTER
 	struct devlink *devlink;
+#endif
 	unsigned long index;
 	char *busname;
 	char *devname;
@@ -219,17 +241,21 @@ mlxdevm_get_from_attrs_lock(struct net *
 	mlxdevms_xa_for_each_registered_get(net, index, mlxdevm) {
 		if (strcmp(mlxdevm->dev->bus->name, busname) == 0 &&
 		    strcmp(dev_name(mlxdevm->dev), devname) == 0) {
+#ifdef HAVE_DEVL_PORT_REGISTER
 			devlink = mlxdevm->devlink;
 			if (devlink)
 				devl_lock(devlink);
+#endif
 			devm_dev_lock(mlxdevm, dev_lock);
 			mlxdevm->mlxdevm_flow = true;
 			if (devm_is_registered(mlxdevm))
 				return mlxdevm;
 			mlxdevm->mlxdevm_flow = false;
 			devm_dev_unlock(mlxdevm, dev_lock);
+#ifdef HAVE_DEVL_PORT_REGISTER
 			if (devlink)
 				devl_unlock(devlink);
+#endif
 		}
 		mlxdevm_put(mlxdevm);
 	}
@@ -242,7 +268,9 @@ static int __mlxdevm_nl_pre_doit(struct
 {
 	bool dev_lock = flags & MLXDEVM_NL_FLAG_NEED_DEV_LOCK;
 	struct mlxdevm_port *mlxdevm_port;
+#ifdef HAVE_DEVL_PORT_REGISTER
 	struct devlink *devlink;
+#endif
 	struct mlxdevm *mlxdevm;
 	int err;
 
@@ -268,14 +296,20 @@ static int __mlxdevm_nl_pre_doit(struct
 
 unlock:
 	devm_dev_unlock(mlxdevm, dev_lock);
+#ifdef HAVE_DEVL_PORT_REGISTER
 	devlink = mlxdevm->devlink;
 	if (devlink)
 		devl_unlock(devlink);
+#endif
 	mlxdevm_put(mlxdevm);
 	return err;
 }
 
+#ifdef HAVE_STRUCT_GENL_SPLIT_OPS
 int mlxdevm_nl_pre_doit(const struct genl_split_ops *ops,
+#else
+int mlxdevm_nl_pre_doit(const struct genl_ops *ops,
+#endif
 			struct sk_buff *skb, struct genl_info *info)
 {
 	return __mlxdevm_nl_pre_doit(skb, info, 0);
@@ -307,18 +341,26 @@ static void __mlxdevm_nl_post_doit(struc
 {
 	bool dev_lock = flags & MLXDEVM_NL_FLAG_NEED_DEV_LOCK;
 	struct mlxdevm *mlxdevm;
+#ifdef HAVE_DEVL_PORT_REGISTER
 	struct devlink *devlink;
+#endif
 
 	mlxdevm = info->user_ptr[0];
 	mlxdevm->mlxdevm_flow = false;
 	devm_dev_unlock(mlxdevm, dev_lock);
+#ifdef HAVE_DEVL_PORT_REGISTER
 	devlink = mlxdevm->devlink;
 	if (devlink)
 		devl_unlock(devlink);
+#endif
 	mlxdevm_put(mlxdevm);
 }
 
+#ifdef HAVE_STRUCT_GENL_SPLIT_OPS
 void mlxdevm_nl_post_doit(const struct genl_split_ops *ops,
+#else
+void mlxdevm_nl_post_doit(const struct genl_ops *ops,
+#endif
 			  struct sk_buff *skb, struct genl_info *info)
 {
 	__mlxdevm_nl_post_doit(skb, info, 0);
@@ -331,13 +373,16 @@ mlxdevm_nl_post_doit_dev_lock(const stru
 	__mlxdevm_nl_post_doit(skb, info, MLXDEVM_NL_FLAG_NEED_DEV_LOCK);
 }
 
+#if defined(HAVE_GENL_INFO_DUMP) || defined (HAVE_GENL_DUMPIT_INFO)
 static int mlxdevm_nl_inst_single_dumpit(struct sk_buff *msg,
 					 struct netlink_callback *cb, int flags,
 					 mlxdevm_nl_dump_one_func_t *dump_one,
 					 struct nlattr **attrs)
 {
 	struct mlxdevm *mlxdevm;
+#ifdef HAVE_DEVL_PORT_REGISTER
 	struct devlink *devlink;
+#endif
 	int err;
 
 	mlxdevm = mlxdevm_get_from_attrs_lock(sock_net(msg->sk), attrs, false);
@@ -346,15 +391,18 @@ static int mlxdevm_nl_inst_single_dumpit
 	err = dump_one(msg, mlxdevm, cb, flags | NLM_F_DUMP_FILTERED);
 
 	devm_unlock(mlxdevm);
+#ifdef HAVE_DEVL_PORT_REGISTER
 	devlink = mlxdevm->devlink;
 	if (devlink)
 		devl_unlock(devlink);
+#endif
 	mlxdevm_put(mlxdevm);
 
 	if (err != -EMSGSIZE)
 		return err;
 	return msg->len;
 }
+#endif
 
 static int mlxdevm_nl_inst_iter_dumpit(struct sk_buff *msg,
 				       struct netlink_callback *cb, int flags,
@@ -362,14 +410,18 @@ static int mlxdevm_nl_inst_iter_dumpit(s
 {
 	struct mlxdevm_nl_dump_state *state = mlxdevm_dump_state(cb);
 	struct mlxdevm *mlxdevm;
+#ifdef HAVE_DEVL_PORT_REGISTER
 	struct devlink *devlink;
+#endif
 	int err = 0;
 
 	while ((mlxdevm = mlxdevms_xa_find_get(sock_net(msg->sk),
 					       &state->instance))) {
+#ifdef HAVE_DEVL_PORT_REGISTER
 		devlink = mlxdevm->devlink;
 		if (devlink)
 			devl_lock(devlink);
+#endif
 		devm_lock(mlxdevm);
 
 		if (devm_is_registered(mlxdevm))
@@ -378,8 +430,10 @@ static int mlxdevm_nl_inst_iter_dumpit(s
 			err = 0;
 
 		devm_unlock(mlxdevm);
+#ifdef HAVE_DEVL_PORT_REGISTER
 		if (devlink)
 			devl_unlock(devlink);
+#endif
 		mlxdevm_put(mlxdevm);
 
 		if (err)
@@ -399,7 +453,13 @@ static int mlxdevm_nl_inst_iter_dumpit(s
 int mlxdevm_nl_dumpit(struct sk_buff *msg, struct netlink_callback *cb,
 		      mlxdevm_nl_dump_one_func_t *dump_one)
 {
+#if defined(HAVE_GENL_INFO_DUMP) || defined (HAVE_GENL_DUMPIT_INFO)
+#ifdef HAVE_GENL_INFO_DUMP
 	const struct genl_info *info = genl_info_dump(cb);
+#else
+	const struct genl_dumpit_info *info = genl_dumpit_info(cb);
+#endif
+
 	struct nlattr **attrs = info->attrs;
 	int flags = NLM_F_MULTI;
 
@@ -409,20 +469,87 @@ int mlxdevm_nl_dumpit(struct sk_buff *ms
 						     attrs);
 	else
 		return mlxdevm_nl_inst_iter_dumpit(msg, cb, flags, dump_one);
+#else
+	int flags = NLM_F_MULTI;
+
+	return mlxdevm_nl_inst_iter_dumpit(msg, cb, flags, dump_one);
+#endif
 }
 
+#ifndef HAVE_GENL_OPS_MAXATTR
+struct nla_policy mlxdevm_nl_policy[MLXDEVM_ATTR_MAX + 1] = {
+#ifdef HAVE_NLA_POLICY_STRICT_START_TYPE
+	[MLXDEVM_ATTR_UNSPEC] = { .strict_start_type =
+		MLXDEVM_ATTR_TRAP_POLICER_ID },
+#endif
+	[MLXDEVM_ATTR_BUS_NAME] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_DEV_NAME] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_PORT_INDEX] = { .type = NLA_U32 },
+	[MLXDEVM_ATTR_PORT_FLAVOUR] = NLA_POLICY_MAX(NLA_U16, 7),
+	[MLXDEVM_ATTR_PORT_PCI_PF_NUMBER] = { .type = NLA_U16, },
+	[MLXDEVM_ATTR_PORT_PCI_SF_NUMBER] = { .type = NLA_U32, },
+	[MLXDEVM_ATTR_PORT_CONTROLLER_NUMBER] = { .type = NLA_U32, },
+	[MLXDEVM_ATTR_PORT_TYPE] = { .type = NLA_U16 },
+	[MLXDEVM_ATTR_ESWITCH_MODE] = { .type = NLA_U16 },
+	[MLXDEVM_ATTR_ESWITCH_INLINE_MODE] = { .type = NLA_U8 },
+	[MLXDEVM_ATTR_ESWITCH_ENCAP_MODE] = { .type = NLA_U8 },
+	[MLXDEVM_ATTR_DPIPE_TABLE_NAME] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_PARAM_NAME] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_PARAM_TYPE] = { .type = NLA_U8 },
+	[MLXDEVM_ATTR_PARAM_VALUE_CMODE] = { .type = NLA_U8 },
+	[MLXDEVM_ATTR_EXT_PARAM_ARRAY_TYPE] = { .type = NLA_U8 },
+	[MLXDEVM_ATTR_FLASH_UPDATE_FILE_NAME] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_FLASH_UPDATE_COMPONENT] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_FLASH_UPDATE_OVERWRITE_MASK] = NLA_POLICY_BITFIELD32(3),
+	[MLXDEVM_ATTR_TRAP_NAME] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_TRAP_ACTION] = { .type = NLA_U8 },
+	[MLXDEVM_ATTR_TRAP_GROUP_NAME] = { .type = NLA_NUL_STRING },
+	[MLXDEVM_ATTR_TRAP_POLICER_ID] = { .type = NLA_U32, },
+	[MLXDEVM_ATTR_RELOAD_ACTION] = { .type = NLA_U8 },
+	[MLXDEVM_ATTR_RELOAD_LIMITS] = NLA_POLICY_BITFIELD32(6),
+	[MLXDEVM_ATTR_NETNS_PID] = { .type = NLA_U32 },
+	[MLXDEVM_ATTR_NETNS_FD] = { .type = NLA_U32 },
+	[MLXDEVM_ATTR_NETNS_ID] = { .type = NLA_U32 },
+	[MLXDEVM_ATTR_RATE_NODE_NAME] = { .type = NLA_NUL_STRING, },
+	[MLXDEVM_ATTR_RATE_TX_SHARE] = { .type = NLA_U64, },
+	[MLXDEVM_ATTR_RATE_TX_MAX] = { .type = NLA_U64, },
+	[MLXDEVM_ATTR_RATE_TX_PRIORITY] = { .type = NLA_U32, },
+	[MLXDEVM_ATTR_RATE_TX_WEIGHT] = { .type = NLA_U32, },
+	[MLXDEVM_ATTR_RATE_PARENT_NODE_NAME] = { .type = NLA_NUL_STRING, },
+	[MLXDEVM_ATTR_RATE_TC_BWS] = NLA_POLICY_NESTED(mlxdevm_dl_rate_tc_bws_nl_policy),
+	[MLXDEVM_ATTR_PORT_FUNCTION] = { .type = NLA_NESTED },
+};
+#endif
+
 struct genl_family mlxdevm_nl_family  = {
 	.name		= MLXDEVM_GENL_NAME,
 	.version	= MLXDEVM_GENL_VERSION,
+	.maxattr = MLXDEVM_ATTR_MAX,
+#if defined(HAVE_GENL_FAMILY_POLICY) && !defined(HAVE_GENL_OPS_MAXATTR)
+        .policy = mlxdevm_nl_policy,
+#endif
 	.netnsok	= true,
 	.parallel_ops	= true,
+#ifndef HAVE_STRUCT_GENL_SPLIT_OPS
+	.pre_doit	= mlxdevm_nl_pre_doit,
+	.post_doit	= mlxdevm_nl_post_doit,
+#endif
 	.module		= THIS_MODULE,
+#ifdef HAVE_STRUCT_GENL_SPLIT_OPS
 	.split_ops	= mlxdevm_nl_ops,
 	.n_split_ops	= ARRAY_SIZE(mlxdevm_nl_ops),
+#else
+	.ops	= mlxdevm_nl_ops,
+	.n_ops	= ARRAY_SIZE(mlxdevm_nl_ops),
+#endif
+#ifdef HAVE_GENL_FAMILY_RESV_START_OP
 	.resv_start_op	= MLXDEVM_CMD_SELFTESTS_RUN + 1,
+#endif
 	.mcgrps		= mlxdevm_nl_mcgrps,
 	.n_mcgrps	= ARRAY_SIZE(mlxdevm_nl_mcgrps),
+#ifdef HAVE_DEVLINK_NOTIFICATIONS_FILTERING
 	.sock_priv_size		= sizeof(struct mlxdevm_nl_sock_priv),
 	.sock_priv_init		= mlxdevm_nl_sock_priv_init,
 	.sock_priv_destroy	= mlxdevm_nl_sock_priv_destroy,
+#endif
 };
