From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/infiniband/hw/mlx5/devx.c

Change-Id: I32706600158ee81196a203191a5adca89c65b898
---
 drivers/infiniband/hw/mlx5/devx.c | 26 +++++++++++++++++++++++++-
 1 file changed, 25 insertions(+), 1 deletion(-)

--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@ -17,6 +17,9 @@
 #include "mlx5_ib.h"
 #include "devx.h"
 #include "qp.h"
+#ifdef HAVE_BASECODE_EXTRAS
+#include <linux/eventfd.h>
+#endif
 #include <linux/xarray.h>
 
 #define UVERBS_MODULE_NAME mlx5_ib
@@ -2252,6 +2255,7 @@ static int devx_umem_get(struct mlx5_ib_
 	if (err)
 		return err;
 
+#ifdef HAVE_DMA_BUF_DYNAMIC_ATTACH_GET_4_PARAMS
 	if (uverbs_attr_is_valid(attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_DMABUF_FD)) {
 		struct ib_umem_dmabuf *umem_dmabuf;
 		int dmabuf_fd;
@@ -2266,8 +2270,14 @@ static int devx_umem_get(struct mlx5_ib_
 		if (IS_ERR(umem_dmabuf))
 			return PTR_ERR(umem_dmabuf);
 		obj->umem = &umem_dmabuf->umem;
-	} else {
+	} else
+#endif	/* HAVE_DMA_BUF_DYNAMIC_ATTACH_GET_4_PARAMS */
+	{
+#ifdef HAVE_MMU_INTERVAL_NOTIFIER
 		obj->umem = ib_umem_get_peer(&dev->ib_dev, addr, size, access_flags, 0);
+#else
+		obj->umem = ib_umem_get_peer(&attrs->driver_udata, addr, size, access_flags, 0);
+#endif
 		if (IS_ERR(obj->umem))
 			return PTR_ERR(obj->umem);
 	}
@@ -2557,7 +2567,11 @@ static void dispatch_event_fd(struct lis
 
 	list_for_each_entry_rcu(item, fd_list, xa_list) {
 		if (item->eventfd)
+#ifdef HAVE_EVENTFD_SIGNAL_GET_1_PARAM
 			eventfd_signal(item->eventfd);
+#else
+			eventfd_signal(item->eventfd, 1);
+#endif
 		else
 			deliver_event(item, data);
 	}
@@ -2814,6 +2828,9 @@ static const struct file_operations devx
 	.read	 = devx_async_cmd_event_read,
 	.poll    = devx_async_cmd_event_poll,
 	.release = uverbs_uobject_fd_release,
+#ifdef HAVE_NO_LLSEEK
+	.llseek	 = no_llseek,
+#endif
 };
 
 static ssize_t devx_async_event_read(struct file *filp, char __user *buf,
@@ -2821,7 +2838,11 @@ static ssize_t devx_async_event_read(str
 {
 	struct devx_async_event_file *ev_file = filp->private_data;
 	struct devx_event_subscription *event_sub;
+#ifndef uninitialized_var
 	struct devx_async_event_data *event;
+#else
+	struct devx_async_event_data *uninitialized_var(event);
+#endif
 	int ret = 0;
 	size_t eventsz;
 	bool omit_data;
@@ -2928,6 +2949,9 @@ static const struct file_operations devx
 	.read	 = devx_async_event_read,
 	.poll    = devx_async_event_poll,
 	.release = uverbs_uobject_fd_release,
+#ifdef HAVE_NO_LLSEEK
+	.llseek	 = no_llseek,
+#endif
 };
 
 static void devx_async_cmd_event_destroy_uobj(struct ib_uobject *uobj,
